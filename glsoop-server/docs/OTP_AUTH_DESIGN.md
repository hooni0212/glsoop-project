# OTP 기반 이메일 인증 설계안 (초안)

> 목표: 이메일 인증을 링크 클릭이 아닌 **번호(OTP) 입력 방식**으로 전환한다.
> 응답은 JSON 규약(`{ ok, message, ... }`)을 유지한다.

---

## 1) 핵심 흐름

### A. 회원가입 요청
1. 사용자가 회원가입 정보를 제출한다.
2. 서버는 사용자 레코드를 생성하되 **미인증 상태**로 저장한다.
3. OTP를 생성하고 **해시로 저장**한 뒤, 이메일로 OTP를 발송한다.
4. 클라이언트는 인증 번호 입력 UI를 노출한다.

### B. OTP 검증
1. 사용자가 OTP를 입력한다.
2. 서버는 저장된 OTP 해시와 비교하여 유효성을 검증한다.
3. 성공 시 `is_verified = 1`로 갱신한다.

---

## 2) 데이터 설계(안)

### 옵션 1: users 테이블에 OTP 컬럼 추가
- `verification_code_hash` (TEXT)
- `verification_expires` (DATETIME)
- `verification_attempts` (INTEGER)

### 옵션 2: 별도 OTP 테이블
- `otp_verifications`
  - `id`, `user_id`, `code_hash`, `expires_at`, `attempts`, `created_at`

> **권장:** 별도 테이블로 분리하여 추후 재발송/이력 관리 용이.

---

## 3) 보안 고려 사항

- **OTP 원문 저장 금지**: 반드시 해시(bcrypt/argon2 등)로 저장.
- **유효시간 제한**: 예) 10분 이내.
- **시도 제한**: 예) 5회 실패 시 잠금.
- **재발송 제한**: 예) 1분 내 재발송 불가, 하루 최대 5회.
- **로그 기록**: 실패/성공 이벤트를 서버 로그로 남김.

---

## 4) API 스펙 제안

### 1) OTP 발송
`POST /api/signup`

**응답 (성공)**
```json
{
  "ok": true,
  "message": "인증 번호를 이메일로 발송했습니다.",
  "user_id": 123
}
```

### 2) OTP 검증
`POST /api/verify-email`

**요청 바디**
```json
{
  "user_id": 123,
  "verification_code": "123456"
}
```

**응답 (성공)**
```json
{
  "ok": true,
  "message": "이메일 인증이 완료되었습니다."
}
```

---

## 5) UX 제안

- 가입 직후 **OTP 입력 화면으로 바로 이동**.
- OTP 입력 실패 시 남은 시도 횟수 표시.
- 재발송 버튼에 **쿨다운 타이머** 노출.

---

## 6) 마이그레이션 전략

- 기존 링크 기반 인증 기능은 일정 기간 병행 지원 후 제거.
- 링크 인증과 OTP 인증이 동시에 활성일 경우, 동일 사용자에 대해
  **최신 발급 방식만 유효**하도록 정책 정의 필요.

