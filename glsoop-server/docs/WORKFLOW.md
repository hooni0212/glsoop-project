
---

## 작업 프로토콜

### 1️⃣ 작업 시작 전: main 최신화

모든 작업은 항상 **최신 main 기준**으로 시작한다.

```bash
# 1) main 브랜치로 이동
git checkout main

# 2) 원격(main)의 최신 내용을 가져오기
git pull origin main
```

---

### 2️⃣ 새 브랜치 생성 후, 그 브랜치에서만 작업하기

항상 최신 main을 기준으로 새 브랜치를 만든다.

```bash
# (이미 1단계에서 main 최신화가 끝난 상태라고 가정)
git checkout main

# 새 브랜치 생성 + 해당 브랜치로 이동
git checkout -b feature/브랜치-이름
# 예시
# git checkout -b feature/mypage-card-ui
```

* 브랜치 이름 규칙: `feature/작업-내용` 형태로 맞춘다.
* 한 브랜치에는 **가급적 하나의 기능/작업만** 넣는다.

---

### 3️⃣ 브랜치에서 기능 추가 / 코드 수정

* 방금 만든 `feature/브랜치-이름` 브랜치에서만 수정 작업을 한다.
* HTML, CSS, JS, 서버 코드 등 필요한 내용을 자유롭게 수정한다.

---

### 4️⃣ 커밋 (VS Code 소스 제어 기능 사용)

명령어를 외우기보다는 **VS Code의 소스 제어 기능**을 사용한다.

1. 왼쪽 사이드바에서 **‘소스 제어(Source Control)’** 탭을 연다.
2. 코드를 수정했다면, `CHANGES`(변경 사항) 목록에 수정된 파일들이 보인다.
3. 각 파일에 마우스를 올리면 오른쪽에 **`+` 아이콘**이 보인다.

   * 이 `+` 버튼을 눌러 **스테이징(Stage)** 한다.
   * 여러 파일을 한 번에 올리고 싶으면, 상단의 **`+`(모두 스테이징)** 를 쓸 수도 있다.
4. 상단 메시지 입력란에 커밋 메시지를 작성한다.

   * 예: `feat: 작업 프로토콜 README 초안 추가`
5. 옆의 **체크(✓) 버튼**을 눌러 **커밋**을 완료한다.

---

### 5️⃣ 브랜치를 원격 저장소(GitHub)에 push

커밋까지 끝났다면, 이제 이 브랜치를 GitHub에 올려서(PR 만들 준비)
다른 사람도 볼 수 있게 한다.

1. VS Code에서:

   1. 왼쪽 **‘소스 제어’** 탭을 연다.
   2. 위쪽의 **`…`(더보기)** 버튼을 클릭한다.
   3. **‘Push’** 또는 **‘Push to…’** 메뉴를 선택한다.

      * VS Code 언어를 한글로 사용할 경우: **‘다음으로 푸시…’** 로 표시될 수 있다.
   4. 처음 푸시하는 브랜치라면, **‘Publish Branch’** 같은 버튼이 나올 수 있다.
      이때 확인을 눌러서 **원격에도 같은 이름의 브랜치**를 만든다.

---

### 6️⃣ GitHub에서 Pull Request(PR) 만들기

브랜치가 GitHub에 올라가면, 웹 브라우저로 GitHub 저장소에 들어가 PR을 만든다.

1. GitHub에서 **glsoop 저장소**로 이동한다.
2. 상단에 **‘Compare & pull request’** 버튼이 보이면 클릭한다.

   * 만약 보이지 않는다면:

     * 상단 **‘Pull requests’** 탭 → **‘New pull request’** 클릭
     * **base**는 `main`, **compare**는 방금 push한 브랜치로 선택한다.
3. PR 제목과 설명을 작성한다.

   * 예시 제목

     * `[feat] 마이페이지 카드 hover 효과 추가`
   * 예시 내용

     * 요약

       * 메인 페이지 글 카드에 hover 효과 추가
     * 변경 내용

       * 카드에 `transition`, `box-shadow`, `transform` 효과 적용
     * 테스트

       * 로컬 환경에서 hover 동작 확인 완료
4. **‘Create pull request’** 버튼을 눌러 PR을 생성한다.

**협업 규칙**

* 가능하면 내가 만든 PR은 **다른 사람이 한 번 보고 merge**한다.
* 아주 단순한 수정(오타, 주석, 작은 스타일 수정 등)처럼
  변경 범위가 매우 작고 명확한 경우에는 팀 내에서 합의 후, 본인이 직접 merge해도 된다.

---

### 7️⃣ PR 승인 후 main에 merge & 모두 main 다시 pull

1. PR이 승인되면, GitHub에서:

   * **‘Merge pull request’** → **‘Confirm merge’**를 눌러 `main`에 병합한다.
2. 병합이 끝난 후, 각자 로컬에서는 **항상 main을 최신으로 맞춘다.**

```bash
# 1) main 브랜치로 이동
git checkout main

# 2) 최신 main 다시 가져오기
git pull origin main
```

* 이렇게 해서 **모든 사람이 동일한 최신 main 상태**에서
  다음 작업을 시작할 수 있도록 유지한다.

---

### 8️⃣ 사용이 끝난 브랜치는 정리 (선택이지만 강력 추천)

PR이 merge된 브랜치는 더 이상 쓸 일이 없으면 정리한다.

* **GitHub 웹에서**

  * PR 페이지 아래쪽의 **‘Delete branch’** 버튼을 눌러 **원격 브랜치**를 삭제한다.
* **로컬(VS Code 터미널)에서는**

```bash
git branch -d feature/브랜치-이름
```

* 이렇게 하면 오래된 브랜치가 쌓이지 않고, 브랜치 목록이 깔끔하게 유지된다.

---

## 9. Git 명령어 치트시트 🧾

> 자주 쓰는 명령어만 골라놓은 **미니 레퍼런스**입니다.
> 브랜치 전략은 위 “작업 프로토콜” 내용을 기본으로 합니다.

### 9-1. 기본 확인 명령어

| 명령어                               | 설명                              |
| --------------------------------- | ------------------------------- |
| `git status`                      | 현재 작업 상태 확인 (변경된 파일, 스테이징 여부 등) |
| `git diff`                        | 아직 스테이징하지 않은 변경 내용 비교           |
| `git diff --staged`               | 스테이징된 내용만 비교                    |
| `git log --oneline --graph --all` | 커밋 히스토리를 한 줄 요약 + 그래프로 보기       |

---

### 9-2. 브랜치 관련

| 명령어                             | 설명                             |
| ------------------------------- | ------------------------------ |
| `git branch -a`                 | 로컬 + 원격 모든 브랜치 목록 보기           |
| `git checkout main`             | main 브랜치로 이동                   |
| `git checkout -b feature/브랜치이름` | 새 브랜치 생성 + 그 브랜치로 이동           |
| `git switch 브랜치이름`              | 다른 브랜치로 이동 (checkout 대신 사용 가능) |
| `git branch -d 브랜치이름`           | **로컬** 브랜치 삭제 (머지된 브랜치 정리용)    |

---

### 9-3. 원격 저장소(GitHub) 관련

| 명령어                              | 설명                               |
| -------------------------------- | -------------------------------- |
| `git pull origin main`           | 원격 origin/main 최신 내용 가져오기        |
| `git push origin 브랜치이름`          | 현재 브랜치를 원격(origin)에 올리기          |
| `git fetch -p`                   | 원격 브랜치 정보 갱신 + 삭제된 브랜치 정리(prune) |
| `git push origin --delete 브랜치이름` | **원격** 브랜치 삭제 (PR 머지 후 정리용)      |

---

### 9-4. 병합 관련 (참고용)

> 브랜치를 main에 합치는 작업은 **GitHub Pull Request**로 하는 것을 기본으로 하고,
> 필요할 때만 로컬에서 직접 merge 한다.

| 명령어               | 설명                 |
| ----------------- | ------------------ |
| `git merge 브랜치이름` | 현재 브랜치에 다른 브랜치를 병합 |

> ⚠️ 로컬에서 `git merge`를 직접 쓰면 충돌이 날 수 있으니,
> **기본은 PR → GitHub에서 Merge** 하는 방식으로 사용하고,
> 충돌 해결이 익숙해지면 천천히 로컬 merge도 활용하자.

---

## 10. 자주 발생하는 상황 & 해결법 (트러블슈팅) 🛠️

> “어… 뭐 잘못 건드린 것 같은데?” 할 때 참고하는 **응급 처치 메뉴얼**입니다.

---

### 10-1. 잘못된 브랜치에서 작업을 시작했을 때

> 예: `main`에서 바로 수정해버렸는데, 원래는 새 브랜치에서 했어야 할 때

#### 1) 현재 브랜치(예: main)에 커밋이 **이미 있다면**

→ 그 커밋을 그대로 가져가는 새 브랜치를 만든다.

```bash
# 1) 현재 브랜치 상태에서 새 브랜치 생성
git checkout -b feature/올바른-브랜치이름

# 2) 앞으로는 이 브랜치에서 계속 작업
# (필요하다면 main에서 해당 커밋을 나중에 정리)
```

* 이렇게 하면, 지금까지 main에서 쌓아둔 커밋들이
  그대로 `feature/올바른-브랜치이름` 으로 “옮겨가는 느낌”이 된다.
* 이후 작업은 전부 이 새 브랜치에서 이어서 하면 된다.

#### 2) 아직 커밋 안 하고 파일만 수정한 경우

`main`에서 그냥 수정만 해놓고 커밋은 안 한 상태라면,
변경 내역을 그대로 새 브랜치로 옮겨서 이어서 작업하면 된다.

```bash
# 1) 현재 변경 내용을 안고 있는 상태에서 새 브랜치 생성 + 이동
git checkout -b feature/올바른-브랜치이름
```

> ✅ 이렇게 하면, 방금까지 `main`에서 수정했던 내용들이
> 그대로 `feature/올바른-브랜치이름` 브랜치 위에서 이어지게 된다.
> 앞으로는 이 브랜치에서만 계속 작업하면 된다.

---

### 10-2. 로컬 변경 사항을 되돌리고 싶을 때

> “아… 이거 그냥 원래 상태로 돌릴 걸 그랬다” 싶을 때 쓰는 패턴.

#### 1) 아직 `git add` 안 했을 때 (워킹 디렉토리만 변경된 상태)

```bash
# 특정 파일만 수정 전(마지막 커밋)으로 되돌리기
git restore 파일이름

# 모든 파일을 수정 전으로 되돌리기
git restore .
```

* 이건 **커밋 자체는 건드리지 않고**, 현재 수정만 날린다.

#### 2) 이미 `git add`까지 한 상태에서 되돌리고 싶을 때

```bash
# 특정 파일의 스테이징 취소 (파일 내용은 그대로 유지)
git reset HEAD 파일이름

# 모든 파일 스테이징 취소
git reset HEAD .
```

* “이번에 `add` 한 거 다시 빼고, 커밋은 나중에 다시 생각해보자” 할 때 사용.

---

### 10-3. 마지막 커밋을 수정·되돌리고 싶을 때

> ⚠️ 아래 명령들은 **아직 원격(origin)에 push 안 한 상태**에서 사용하는 것을 추천.
> 이미 push한 커밋을 바꾸면, 히스토리가 꼬일 수 있다.

#### 1) 마지막 커밋 메시지만 바꾸고 싶을 때

```bash
git commit --amend
```

* 에디터가 열리면 메시지만 수정하고 저장하면 된다.
* 커밋 내용(파일)은 그대로 두고, **메시지만 교체**하는 개념.

#### 2) 마지막 커밋을 취소하고, 변경 사항은 남겨두고 싶을 때

```bash
git reset --soft HEAD~1
```

* “커밋만 지우고, 스테이징된 상태로 돌려놓기” 느낌.
* 다시 커밋 메시지를 다듬어서 새로 커밋할 때 유용.

#### 3) 마지막 커밋 + 변경 내용까지 전부 날리고 싶을 때 (매우 위험)

```bash
git reset --hard HEAD~1
```

> ⚠️ `--hard`는 정말 조심해서 써야 한다.
> 되돌리기 전의 변경 내용은 **거의 복구 불가**라고 생각하는 게 마음 편하다.

---

### 10-4. `git pull` / `git merge` 중에 충돌(conflict)이 났을 때

보통 이런 메시지가 나온다:

> `CONFLICT (content): Merge conflict in ...`

#### 1) 먼저 현재 상태 확인

```bash
git status
```

* 어떤 파일에 충돌이 났는지 파일 목록이 보인다.

#### 2) 충돌 난 파일 열어서 수정

* VS Code에서는 충돌 부분에 이런 표시가 생긴다:

```text
<<<<<<< HEAD
(내 코드)
=======
(다른 브랜치 코드)
>>>>>>> 브랜치이름
```

* 이 부분을 보면서

  * 내 코드만 살릴지
  * 상대 브랜치 코드만 살릴지
  * 둘을 합쳐서 새 코드를 만들지
    결정해서 **직접 수정**한다.

#### 3) 충돌 마커 삭제 후 저장

* `<<<<<<<`, `=======`, `>>>>>>>` 이런 줄들을 전부 지우고
* 최종 코드만 남긴다.

#### 4) 충돌 해결된 파일들을 다시 `add` + 커밋

```bash
# 충돌 해결한 파일들 스테이징
git add 해결한파일1 해결한파일2

# 커밋
git commit -m "chore: merge conflict 해결"
```

---

### 10-5. merge 과정이 너무 꼬였을 때의 전략

> “이제 뭘 해도 에러 뜨고, 머리가 아프다…” 싶은 상황일 때.

1. **우선 현재 바뀐 파일을 안전하게 복사해 둔다.**

   * VS Code에서 필요한 코드만 다른 곳(메모장, 새 파일 등)에 붙여넣기.
2. Git 입장에서는 **깔끔한 상태로 돌아간 다음**,
   새로운 브랜치를 만들어 다시 필요한 변경만 적용한다.

예시:

```bash
# 1) main으로 이동 + 최신으로 맞추기
git checkout main
git pull origin main

# 2) 새로운 안전한 작업용 브랜치 생성
git checkout -b feature/다시-정리한-브랜치

# 3) 아까 복사해둔 코드들을 이 브랜치에서 차근차근 다시 적용
#    → 파일 수정 후, add/commit/push/PR 진행
```

> 즉, “꼬인 히스토리를 억지로 살리지 말고,
> **새 브랜치에서 정리해서 다시 만든다**”라는 마인드.

---

### 10-6. 사고를 줄이는 Git 사용 습관 💡

1. **push 전에 항상 한 번 보는 2줄**

   ```bash
   git status
   git log --oneline -5
   ```

   * “지금 어디 브랜치인지, 방금까지 무슨 커밋을 했는지”를 자주 확인하는 습관.

2. **main에서는 직접 작업하지 않기**

   * 항상 `feature/…` 브랜치에서 작업 → PR 생성 → GitHub에서 `main`에 merge.
   * main은 항상 “언제든 배포 가능한 안정 버전”이라는 느낌으로 다루기.

3. **조금이라도 불안하면 새 브랜치 파기**

   ```bash
   git checkout -b temp/실험-브랜치
   ```

   * “이거 해봤다가 망하면 어떡하지?” 싶은 건 전부 `temp/…` 브랜치에서 먼저 시도.
   * 괜찮다 싶으면 나중에 정식 `feature/…`로 다시 만들거나, 거기서부터 이어서 정리.

4. **브랜치 이름을 보고도 바로 내용이 떠오르게 짓기**

   * 예:

     * `feature/mypage-edit-modal`
     * `fix/login-session-bug`
     * `chore/readme-workflow-guide`
   * 나중에 `git branch -a` 했을 때, 이름만으로도 “아 이거 그거구나” 알 수 있게.

5. **작업 단위를 너무 크게 잡지 않기**

   * “마이페이지 UI 수정 + 로그인 리팩터링 + 서버 구조 변경”을
     한 브랜치/한 커밋에 때려넣지 말고,
   * **작업을 쪼개서 브랜치/커밋도 쪼개기**
     → 나중에 문제 생겨도 원인 찾기, 되돌리기가 훨씬 편해진다.

---

## 11. SQLite DB 백업 프로토콜 (WAL 모드 기준) 🗄️

> 글숲은 `PRAGMA journal_mode = WAL` 을 사용한다.
> WAL 모드에서는 DB 변경분이 `users.db` 본파일에 바로 반영되지 않고
> `users.db-wal` / `users.db-shm` 에 남아 있을 수 있다.
> 따라서 `cp users.db ...` 만으로는 **최신 변경분이 백업에서 누락될 수 있음**.

---

### 11-1. 파일 의미 (정상 동작)

| 파일             | 의미                                   |
| -------------- | ------------------------------------ |
| `users.db`     | 기본 DB 파일(스키마/데이터 본체)                 |
| `users.db-wal` | 최신 변경 내역이 쌓이는 로그 파일(Write-Ahead Log) |
| `users.db-shm` | WAL 동작을 위한 공유 메모리(메타) 파일             |

> `users.db`가 “둘로 쪼개진 것”이 아니라, WAL 모드에서 **보조 파일 2개가 추가로 생성**된 것이다.

---

### 11-2. ✅ 가장 안전한 최신 스냅샷 백업 (추천)

**서버(node)를 끈 다음**, 아래 1줄로 “최신 상태가 반영된 DB 스냅샷”을 만든다.

```bash
sqlite3 users.db ".backup 'users.db.safe_$(date +%Y%m%d_%H%M%S).bak'"
```

(선택) 무결성 체크:

```bash
sqlite3 users.db "PRAGMA integrity_check;"
```

---

### 11-3. 서버를 끄기 어렵다면 (차선책): WAL까지 “세트 백업”

> 서버가 실행 중이면 백업 타이밍에 따라 일관성이 깨질 수 있다.
> 가능하면 서버 종료 후 진행을 권장한다.

```bash
ts=$(date +%Y%m%d_%H%M%S)
cp users.db "users.db.full_$ts"
cp users.db-wal "users.db-wal.full_$ts" 2>/dev/null
cp users.db-shm "users.db-shm.full_$ts" 2>/dev/null
```

---

### 11-4. 체크포인트(선택): WAL 내용을 users.db로 합치기

**서버 종료 후** 실행 권장.

```bash
sqlite3 users.db "PRAGMA wal_checkpoint(FULL);"
```

> 실행 후 `users.db`의 수정 시간이 갱신되거나, `users.db-wal` 크기가 줄어드는 경우가 많다.

---

### 11-5. 복구(restore) 방법

#### A) `.backup`로 만든 단일 파일로 복구 (추천)

```bash
# (권장) 기존 파일을 잠깐 보관
mv users.db users.db.before_restore_$(date +%Y%m%d_%H%M%S) 2>/dev/null

# 복구
cp users.db.safe_YYYYMMDD_HHMMSS.bak users.db
```

#### B) “세트 백업(3개 파일)”으로 복구한 경우

백업해둔 파일들을 원래 이름으로 되돌린다:

* `users.db.full_*` → `users.db`
* `users.db-wal.full_*` → `users.db-wal`
* `users.db-shm.full_*` → `users.db-shm`

그 다음 서버 실행.

---

### 11-6. 핵심 요약 (한 줄)

✅ WAL 모드에서는 `users.db`만 복사하면 최신 변경분이 빠질 수 있으니, **DB 수정 전엔 `.backup` 스냅샷을 떠라.**

---
